package main

import (
	"fmt"
	"log"
	"math/big"
	"strings"
)

// DECIMALS 存储已知 token 的小数位数
var DECIMALS = map[string]int{
	"0xdac17f958d2ee523a2206206994597c13d831ec7": 6,  // USDT
	"0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48": 6,  // USDC
	"0xd533a949740bb3306d119cc777fa900ba034cd52": 18, // CRV
}

// Triple 结构体用于存储解码后的数据
type Triple struct {
	Index     int
	Token     string
	Recipient string
	AmountRaw *big.Int
}

func main() {

	inputHex := "0xca350aa60000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000003d090000000000000000000000000000000000000000000000000000000000000001c000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec70000000000000000000000003bc3d842dbcf48c2da5694d65e5b464f6dac62a60000000000000000000000000000000000000000000000000000000048b05f57000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7000000000000000000000000bfba41fe62f50d833ab9163d35367c70953813fc000000000000000000000000000000000000000000000000000000000bdb793c000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec70000000000000000000000003968632e09ecd90205a5b89268141b55c52315360000000000000000000000000000000000000000000000000000000001314e9c000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7000000000000000000000000378d1a1793911b6b86722158a0a7b96bb1840dde000000000000000000000000000000000000000000000000000000000bed1215000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7000000000000000000000000627fc6f932ef21f4394c93a311f2c6ef3933d6f200000000000000000000000000000000000000000000000000000000011e6bfc000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec70000000000000000000000008e6874a980c2ece3de760b3c3651a4cc4041ce35000000000000000000000000000000000000000000000000000000003b9d244e000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec700000000000000000000000057c2290dc3e161a3bcd340336a43800b8dbf9a62000000000000000000000000000000000000000000000000000000001cf6403e000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7000000000000000000000000575064ad83fefdd5ca9b183a0a0708d815105e3e00000000000000000000000000000000000000000000000000000000015cf80a000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7000000000000000000000000f1998f1c521398bda10c834a0de5862a1fa402d600000000000000000000000000000000000000000000000000000000008da347000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7000000000000000000000000141c89edf2d6f8e7835d5e986028fbe7a7e1200b0000000000000000000000000000000000000000000000000000000007571784000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7000000000000000000000000a5877d8e394c844ed1fca569c67c95a75da77f2500000000000000000000000000000000000000000000000000000004a817c800000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7000000000000000000000000f80b91774eb8f60d982344d67f5dea33e7b8c464000000000000000000000000000000000000000000000000000000001ca8f6e7000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec70000000000000000000000000f3e94dc44fc37e4781d03bcdc051691b2c6c50000000000000000000000000000000000000000000000000000000000398b5b4e000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7000000000000000000000000e3c6ff44211d15986e2251b0db503845dab83152000000000000000000000000000000000000000000000000000000000c416c6e000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7000000000000000000000000532b5104568ac1fea4cb3dc17702d0a037b1991f00000000000000000000000000000000000000000000000000000000112547ba000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec700000000000000000000000065c6f2e4d50f13b28735f431fce672134298778200000000000000000000000000000000000000000000000000000000597224f0000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec700000000000000000000000007b71dbf8a0446db62d669b1401f26c4e93087510000000000000000000000000000000000000000000000000000000005f68716000000000000000000000000cbb7c0000ab88b473b1f5afd9ef808440eed33bf00000000000000000000000000b275f2b302f6eb55bc94bb6e0fe8a79a7e3a2000000000000000000000000000000000000000000000000000000000004a4eda000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb4800000000000000000000000045c81c680a7ea1854328f4a663f38fda98f3b6a0000000000000000000000000000000000000000000000000000000002cb0db7f000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb4800000000000000000000000010c49f4c340b27117e154843169fbc8051a5d4dc0000000000000000000000000000000000000000000000000000000005f5e100000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000834678c3b90084b86ddd96c1bbad60a31c97b1df000000000000000000000000000000000000000000000000000004c0a23c4210000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb480000000000000000000000000ee2ab0d8e5da8b79590152c4bec9753c8cdfbe1000000000000000000000000000000000000000000000000000000001b9e7c19000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000fbb5677d4d4b3d5eb68fc2626eac3732f3a103f00000000000000000000000000000000000000000000000000000000001dbc4e0000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000b0e83cfa64031ad1c15cdaf9fa1a4942de8c557d000000000000000000000000000000000000000000000000000000003443caaf000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000000102139e4e2c7cd3681a9675f7b2baafb12362000000000000000000000000000000000000000000000000000000004bf1c6f6000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000a26678b44fd7628723591c7c252458cc290290af0000000000000000000000000000000000000000000000000000000001c6877f000000000000000000000000967da4048cd07ab37855c090aaf366e4ce1b9f4800000000000000000000000089b537d4e0de035303dc1bdae18394f7a6c15c360000000000000000000000000000000000000000000000900215c8a7d9b7b000000000000000000000000000d533a949740bb3306d119cc777fa900ba034cd52000000000000000000000000bc8a0f5e41857292d12ef620e2a5895ce65a5ce00000000000000000000000000000000000000000000016e40a3bf4ea80e9ac00"

	// 去掉 0x 前缀
	if strings.HasPrefix(inputHex, "0x") {
		inputHex = inputHex[2:]
	}

	// 取出 selector（前 4 字节=8 hex），剩下的是参数区
	if len(inputHex) < 8 {
		log.Fatal("输入数据太短，无法提取 selector")
	}
	selector := inputHex[:8]
	data := inputHex[8:]

	fmt.Println("Function selector:", selector)
	if len(data)%64 != 0 {
		fmt.Printf("⚠ data 不是 32 字节对齐，长度= %d\n", len(data))
	}

	// 把 data 按 32 字节（64 个十六进制字符）切块
	slotSize := 64
	var slots []string
	for i := 0; i < len(data); i += slotSize {
		end := i + slotSize
		if end > len(data) {
			end = len(data)
		}
		slots = append(slots, data[i:end])
	}

	fmt.Println("Total slots:", len(slots))
	fmt.Println("We will try to interpret as [token, recipient, amount] triples")

	// 假设从第 0 个 slot 开始就是 token, recipient, amount 循环
	var triples []Triple
	for i := 0; i+2 < len(slots); i += 3 {
		tokenSlot := slots[i]
		toSlot := slots[i+1]
		amountSlot := slots[i+2]

		token, err := decodeAddress(tokenSlot)
		if err != nil {
			log.Printf("警告：解码 token 地址失败 at index %d: %v", i/3, err)
			continue
		}

		recipient, err := decodeAddress(toSlot)
		if err != nil {
			log.Printf("警告：解码 recipient 地址失败 at index %d: %v", i/3, err)
			continue
		}

		amountRaw, err := hexToBigInt(amountSlot)
		if err != nil {
			log.Printf("警告：解码 amount 失败 at index %d: %v", i/3, err)
			continue
		}

		triples = append(triples, Triple{
			Index:     i / 3,
			Token:     token,
			Recipient: recipient,
			AmountRaw: amountRaw,
		})
	}

	// 打印前 50 条看一眼（数量太大怕刷屏）
	limit := 50
	if len(triples) < limit {
		limit = len(triples)
	}

	for _, t := range triples[:limit] {
		fmt.Printf("\n--- index %d ---\n", t.Index)
		fmt.Println("token    :", t.Token)
		fmt.Println("recipient:", t.Recipient)
		fmt.Println("amount   :", formatAmount(t.Token, t.AmountRaw))
	}

	fmt.Printf("\nTotal decoded triples (粗略): %d\n", len(triples))
}

// decodeAddress 从一个 32 字节的 slot 中解码出地址（后 20 字节）
func decodeAddress(slot string) (string, error) {
	if len(slot) != 64 {
		return "", fmt.Errorf("slot 长度不为 64，实际为 %d", len(slot))
	}
	// 32 字节里，后 20 字节是地址, 对应 hex 字符串是后 40 个字符
	// 前 12 字节 (24 个 hex 字符) 是 padding
	return "0x" + slot[24:], nil
}

// hexToBigInt 将十六进制字符串转换为 *big.Int
func hexToBigInt(hexStr string) (*big.Int, error) {
	// `SetString` 方法会自动处理 "0x" 前缀，但为了保险起见，我们确保没有
	hexStr = strings.TrimPrefix(hexStr, "0x")
	val := new(big.Int)
	_, success := val.SetString(hexStr, 16)
	if !success {
		return nil, fmt.Errorf("无法将 '%s' 转换为 big.Int", hexStr)
	}
	return val, nil
}

// formatAmount 格式化 token 数量，如果知道小数位数的话
func formatAmount(token string, raw *big.Int) string {
	t := strings.ToLower(token)
	decimals, ok := DECIMALS[t]
	if !ok {
		return raw.String() + " (raw)"
	}

	// 计算基数: 10^decimals
	base := new(big.Int).Exp(big.NewInt(10), big.NewInt(int64(decimals)), nil)

	// 计算整数部分和小数部分
	intPart := new(big.Int).Div(raw, base)
	fracPart := new(big.Int).Mod(raw, base)

	if fracPart.Cmp(big.NewInt(0)) == 0 {
		return intPart.String()
	}

	// 格式化小数部分，并补零
	fracStr := fmt.Sprintf("%0*s", decimals, fracPart.String())
	// 去掉末尾的零
	fracStr = strings.TrimRight(fracStr, "0")

	return fmt.Sprintf("%s.%s", intPart.String(), fracStr)
}